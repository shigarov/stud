# Лабораторные работы

## Оценки

См. [экзамен (зачет)](exam.md)

## Задания

- Обязательные задания обозначены звездочкой.
- Если задание предлагает несколько вариантов, то достаточно выбрать и сделать только один из них.

### 1. Массивы

Разработать приложение командной строки с обязательным вводом или передачей некоторых пользовательских параметров (входных данных).

*Варианты:*

1. Определить принадлежит ли одна последовательность чисел другой последовательности.
2. Найти произведение двух матриц.
3. Возвести матрицу в степень.
4. Найти минимум среди значений некоторой агрегации (суммы, произведения и пр.) элементов строк матрицы.
5. Найти максимум среди значений некоторой агрегации (суммы, произведения и пр.) элементов диагоналей, параллельных главной диагонали квадратной матрицы.
6. Упорядочить строки (или столбцы) матрицы по значениям некоторой агрегации (суммы, произведения и пр.) их элементов.
7. Вычислить значение задаваемой пользователем агрегации элементов массива.
8. Вычислить количество отрицательных и положительных чисел в n-мерном массиве чисел (где n задаётся пользователем).
9. Найти [наибольший общий делитель](https://en.wikipedia.org/wiki/Greatest_common_divisor) для последовательности чисел.
10. Реализовать любой из известных [алгоритмов сортировки](https://en.wikipedia.org/wiki/Sorting_algorithm).
11. Реализовать [алгоритм поиска в глубину](https://en.wikipedia.org/wiki/Depth-first_search) на графе, заданном [матрицей смежности](https://en.wikipedia.org/wiki/Adjacency_matrix).
12. Реализовать [алгоритм поиска в ширину](https://en.wikipedia.org/wiki/Breadth-first_search) на графе, заданном [матрицей смежности](https://en.wikipedia.org/wiki/Adjacency_matrix).

###  2. Строки

Разработать приложение командной строки с обязательным вводом или передачей некоторых пользовательских параметров (входных данных).

*Варианты:*

 1. Упорядочить слова в строке лексикографически. 
 2. Упорядочить слова в строке по длине. 
 3. Упорядочить слова в строке по их встречаемости. 
 4. Найти слово в строке, встречающееся наибольшее количество раз. 
 5. Найти в строке слово, которое включает заданный символ наибольшее количество раз. 
 6. Выбрать из строки все слова, являющиеся палиндромами.
 7. Разработать калькулятор командной строки. 
 8. Выбрать из строки все подстроки, заключенные внутри пар двойных кавычек с учетом    экранирования.
 9. Найти в сроке слово с наибольшим количеством согласных звуков. 
 10. [Распознать именованные сущности](https://en.wikipedia.org/wiki/Named-entity_recognition) в сроке с помощью какой-либо известной NLP библиотеки ([Stanford  CoreNLP](https://stanfordnlp.github.io/CoreNLP), [OpenNLP](https://opennlp.apache.org) или др.).
 11. Вычислить [расстояние Левенштейна](https://en.wikipedia.org/wiki/Levenshtein_distance) между всеми парами слов в строке. 
 12. Найти в сроке все слова с одинаковым звучанием с помощью любого известного [фонетического алгоритма](https://en.wikipedia.org/wiki/Phonetic_algorithm).

### 3. Объекты и классы*

Разработать классы, представляющие связанные между собой сущности некоторого предмета.

*Последовательность выполнения задания:*

1. Выбрать Предмет моделирования (предложить самостоятельно).
2. Спроектировать Предметную модель и представить ее в виде UML-диаграммы классов.
3. Разработать Сущностные классы, реализующие Предметную модель.
4. Разработать Main-класс, демонстрирующий создание и использование объектов Сущностных классов.

*Обязательные требования:*

1. Предметная модель должна включать по крайней мере 3 связанных между собой сущности.
2. Каждая сущность должна быть реализована одним открытым классом верхнего уровня.
3. Каждый сущностный класс должен следовать соглашениям [JavaBeans](https://en.wikipedia.org/wiki/JavaBeans).
4. Каждый сущностный класс должен включать поля, методы и конструкторы.
5. По крайней мере в одном из классов должна быть реализована перегрузка методов или конструкторов.
6. По крайней мере один из классов должен наследовать другой класс с переопределением его методов.
7. По крайней мере один из классов должен включать статические поля или методы.
8. Каждый сущностный класс должен переопределять методы `toString`, `equals`, `hashCode`.

*Порядок сдачи задания:*

1. Продемонстрировать UML-диаграмму классов Предметной модели.
2. Продемонстрировать Сущностные классы, реализующие Предметную модель в соответствии с Обязательными требованиями.
3. Продемонстрировать создание и использование объектов ваших классов.
4. Объяснить на примере ваших классов принципы инкапсуляции, наследования и полиморфизма.
5. Объяснить на примере ваших классов разделение полей и методов на статические и динамические.
6. Продемонстрировать сериализацию и десериализацию объектов ваших классов.

*Примеры моделируемых предметов*

1. [Графические примитивы: точка, линия, прямоугольник, эллипс](https://git.icc.ru/stud/java/blob/master/uml_figures.svg).
2. [Факультет: студент, зачетка, преподаватель, кафедра, курс](https://git.icc.ru/stud/java/blob/master/uml_institute.svg).
3. [Несколько примеров в виде UML-диаграмм классов доступно здесь](https://www.uml-diagrams.org/class-diagrams-examples.html).

###  4. Файлы

Разработать приложение командной строки с обязательным вводом или передачей некоторых пользовательских параметров (входных данных).

*Варианты:*

1. Заменить в текстовом файле все вхождения одной строки на другую строку.
2. Извлечь все слова из текстового файла и записать их в виде списка (каждое слово с новой строки) в другой текстовый файл.
3. Извлечь названия заголовков (`\chapter`, `\section`, `\subsection`, `\subsubsection`) из LaTeX файлов в заданной директории и вывести результат в виде дерева в текстовый файл.
4. Извлечь названия заголовков (`h1`, `h2`, ..., `h6`) из HTML файлов в заданной директории и вывести результат в виде дерева в текстовый файл.
5. Извлечь сигнатуры методов и конструкторов из Java  файлов в заданной директории и записать результат в текстовый файл.
6. Извлечь поля и значения инициализации из Java  файлов в заданной директории и вывести результат в properties  файл в виде «поле = значение».
7. Сравнить два заданных текстовых файла и записать разницу в текстовый файл.
8. Сравнить структуру двух заданных директорий и записать разницу в текстовый файл.
9. Найти все текстовые файлы, содержащие заданную строку, и записать список найденных файлов в текстовый файл.
10. Сформировать список файлов заданной директории (включая поддиректории), упорядоченный по выбираемому пользователем критерию (название, тип, объём) и записать результат в текстовый файл.
11. Отследить изменения, происходящие внутри заданной директории (создание, копирование, и удаление файлов и поддиректорий), в течении некоторого времени, и записать результат в текстовый файл.
12. Переименовать все файлы в заданной директории (включая поддиректории) по задаваемой пользователем маске.

###  5.  Обобщенное программирование

Разработать собственную коллекцию без использования любых классов Java Collection, но обязательным применением [обобщенных типов](https://docs.oracle.com/javase/tutorial/java/generics/types.html).

*Варианты:*

1. [Динамический массив](https://en.wikipedia.org/wiki/Dynamic_array).
2. [Ассоциативный массив](https://en.wikipedia.org/wiki/Associative_array).
3. [Связный список](https://en.wikipedia.org/wiki/Linked_list).
4. [Стек](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)).
5. [Очередь](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)).
6. [Двунаправленная очередь](https://en.wikipedia.org/wiki/Double-ended_queue).
7. [Очередь с приоритетом](https://en.wikipedia.org/wiki/Priority_queue).
8. [Двоичное дерево](https://en.wikipedia.org/wiki/Binary_tree).
9. [Дерево](https://en.wikipedia.org/wiki/Tree_(data_structure)).
10. [Граф](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)).
11. [Ориентированный граф](https://en.wikipedia.org/wiki/Directed_graph).
12. [Множество](https://en.wikipedia.org/wiki/Set_(abstract_data_type)).

###  6. Графический пользовательский интерфейс

Разработать настольное приложение с использованием одной из библиотек визуальных компонент: [AWT](https://en.wikipedia.org/wiki/Abstract_Window_Toolkit), [Swing](https://en.wikipedia.org/wiki/Swing_(Java)), [JavaFX](https://en.wikipedia.org/wiki/JavaFX) или [SWT](https://en.wikipedia.org/wiki/Standard_Widget_Toolkit).

*Варианты:*

1. Графический редактор.
2. Текстовый редактор.
3. Электронная таблица.
4. Инженерный калькулятор.
5. Просмотр PDF документов на основе библиотеки [PDFBox](https://pdfbox.apache.org) или [iText](https://itextpdf.com).
6. Визуализация наборов данных в виде графиков (диаграмм).
7. Визуализация физических законов на основе какого-либо [физического движка](https://en.wikipedia.org/wiki/Physics_engine) (например, [JBox2D](http://www.jbox2d.org)).

###  7. Рефлексия

Разработать приложение для инспектирования Java классов с помощью Java  Reflection  API.

*Обязательно выполнить следующие шаги:*

1. Реализовать динамическую загрузку классов, предназначенных для инспектирования.
2. Реализовать инспекцию классов с целью проверки следования [соглашениям именования Java](https://www.oracle.com/technetwork/java/codeconventions-135099.html).
3. Вывести те случаи, когда имена классов, полей и методов не соответствуют соглашениям именования Java.

###  8. Наборы данных

Разработать приложение визуализации некоторого набора данных.

*Обязательно выполнить следующие шаги:*

1. Найти набор данных в формате [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) или [JSON](https://en.wikipedia.org/wiki/JSON), в котором представлено по крайней мере два измерения (например, время и количество чего-либо). Поискать можно на одном из доступных порталов [открытых данных](https://en.wikipedia.org/wiki/Open_data) (например, [http://data.gov.ru](http://data.gov.ru)). 
2. Реализовать чтение набора данных (для чтения CSV данных можно использовать библиотеку [Commons CSV](https://commons.apache.org/proper/commons-csv), а для чтения JSON — библиотеку [GSON](https://github.com/google/gson)).
3. Реализовать генерацию графика (диаграммы), отражающего изменение (распределение) значений измерений, представленных в наборе данных.
4. Реализовать запись сгенерированного графика (диаграммы) в изображение (файл любого графического формата данных).

*Примеры наборов данных*


###  9. Многопоточное программирование

Разработать многопоточное приложение на основе Java Concurrency API. Сравнить его производительность в однопоточном и многопоточном режимах.

*Варианты:*
1. Многопоточное чтение текстового файла.
2. Многопоточное чтение бинарного файла.
3. Многопоточный полнотекстовый поиск в наборе текстовых файлов.
4. Многопоточный полнотекстовый поиск документа по набору текстовых файлов.
5. Многопоточный полнотекстовый поиск документа по набору HTML файлов.
6. Многопоточный полнотекстовый поиск документа по набору Word файлов.
7. Многопоточный поиск файла по имени в файловой системе.